INCLUDE "contador_mod_4.inc";
INCLUDE "contador_mod_6.inc";
INCLUDE "contador_mod_10.inc";
INCLUDE "contador_mod_10_inicial.inc";
INCLUDE "contador_mod_24.inc";
INCLUDE "contador_clock.inc";
INCLUDE "display_clock.inc";
INCLUDE "buzzer_clock.inc";
INCLUDE "multiplexador_display.inc";
INCLUDE "2x4_decoder.inc";
INCLUDE "BCD_7Segment_Decoder.inc";
INCLUDE "frequencia_contador_1Hz.inc";
INCLUDE "selecionador_digito.inc";

SUBDESIGN despertador
(
	clk: INPUT;						%50Mhz%
	ajuste : INPUT; 				%key1 %
	up : INPUT; 					%key2/button2 %
	trocar : INPUT; 				%key3/button3 %
	troca_modo : INPUT;			%key4/button4 %
	
	sec_unidades[3..0],sec_dezenas[3..0],min_unidades[3..0] : OUTPUT;
	min_dezenas[3..0],horas_unidades[3..0],horas_dezenas[3..0] : OUTPUT;
	tc_segundos,tc_minutos,tc_horas : OUTPUT;
	
	Seg7Output[6..0] : OUTPUT;
	AnodeOutput[3..0] : OUTPUT;
	digito_selecionado[3..0] : OUTPUT;
	
	acorda_mu[3..0],acorda_md[3..0],acorda_hu[3..0],acorda_hd[3..0] : OUTPUT;
	buzzer : OUTPUT;
)

VARIABLE
	%Clocks para testar na placa%
	cont_clock : frequencia_contador_1Hz;
	refresh_clock : display_clock;
	buzzer_clk : buzzer_clock;
	
	% Horas%
	mod24 : contador_mod_24;
	% Minutos%
	mod6_min : contador_mod_6;
	mod10_min : contador_mod_10_inicial;
	% Segundos %
	mod6_seg : contador_mod_6;
	mod10_seg : contador_mod_10_inicial;
	
	%Cuida do dígito que está sendo incrementado%
	select_dig : selecionador_digito;
	
	%Hora de acordar %	
	acorda_hora : contador_mod_24;
	acorda_min_d : contador_mod_6;
	acorda_min_u : contador_mod_10;
	
	%Flip-Flop JK que controlará quando entra no modo de ajuste do Alarme %
	controle_modo_alarme : JKFF;	
	
	%Chave do display a ser exibido%
	chaveador : contador_mod_4;
	
	%Multiplexador do Display%
	mux : multiplexador_display;
	
	%Decoder de 7 segmentos%
	bcd_7Seg_dec : BCD_7Segment_Decoder;
	
	%Decoder 2 : 4 %
	decoder : 2x4_decoder;
		
	%Variável booleana para comparar a hora do relógio com a hora do alarme %
	comparador : NODE;
	
BEGIN			
	select_dig.trocar = trocar;
		
	%Debugging %
	digito_selecionado[] = select_dig.digito[];
	acorda_mu[] = acorda_min_d.q[];
	acorda_md[] = acorda_min_d.q[];
	acorda_hu[] = acorda_hora.lsd[3..0];
	acorda_hd[] = acorda_hora.msd[3..0];

	controle_modo_alarme.j = VCC;
	controle_modo_alarme.k = VCC;
	controle_modo_alarme.clk = ajuste & troca_modo;

	%Variável Boleana que guarda o valor da comparação entre a hora atual e a hora do desperatador.
	Além disso, também há dois botões que precisam ser pressionados para que a variável seja falsa %
	
	comparador = (acorda_hora.msd[] == mod24.msd[] & acorda_hora.lsd[] == mod24.lsd[] 
						& acorda_min_d.q[] == mod6_min.q[] & acorda_min_u.q[] == mod10_min.q[])
						& !(trocar & troca_modo) & mod10_min.q[] != 0;
		
	%Divisão de frequência% 	
	
	%Buzzer%
	buzzer_clk.clock = clk;
	buzzer_clk.enable = VCC;
	
	
	%Visor %
	refresh_clock.clock = clk;
	refresh_clock.enable = VCC;
	
	%Contador %
	
	cont_clock.clock = clk;
	cont_clock.enable = VCC;
	
	IF !ajuste & !comparador THEN
		%Começando a contar os segundos%
		mod10_seg.clock = cont_clock.clock_saida;
		mod6_seg.clock = cont_clock.clock_saida;
		
		mod10_seg.enable = VCC;
		mod6_seg.enable = mod10_seg.tc;
		
		sec_unidades[3..0] = mod10_seg.q[3..0];
		sec_dezenas[3..0] = mod6_seg.q[3..0];
		
		tc_segundos = mod6_seg.tc;
		
		%Começando a contar os minutos%
		mod10_min.clock = cont_clock.clock_saida;
		mod6_min.clock = cont_clock.clock_saida;
		
		mod10_min.enable = tc_segundos;
		mod6_min.enable = mod10_min.tc;
		
		min_unidades[3..0] = mod10_min.q[3..0];
		min_dezenas[3..0] = mod6_min.q[3..0];
		
		tc_minutos = mod6_min.tc;
		
		%Começando a contar as horas%	
		mod24.ajuste = ajuste;
		mod24.clock_low = cont_clock.clock_saida;
		mod24.clock_high = cont_clock.clock_saida;
		mod24.enable = tc_minutos;	
		
		horas_unidades[3..0] = mod24.lsd[3..0];
		horas_dezenas[3..0] = mod24.msd[3..0];
		
		tc_horas = mod24.tc;
	ELSIF ajuste & !comparador THEN
		IF !controle_modo_alarme THEN
		
			%Começando a contar os segundos%
			mod10_seg.clock = GND;
			mod6_seg.clock = GND;
			
			mod10_seg.enable = VCC;
			mod6_seg.enable = mod10_seg.tc;
			
			sec_unidades[3..0] = mod10_seg.q[3..0];
			sec_dezenas[3..0] = mod6_seg.q[3..0];
			
			tc_segundos = mod6_seg.tc;
			
			%Começando a contar os minutos%
			mod10_min.clock = up & select_dig.digito[0];
			mod6_min.clock = up & select_dig.digito[1];
			
			mod10_min.enable = VCC;
			mod6_min.enable = VCC;
			
			min_unidades[3..0] = mod10_min.q[3..0];
			min_dezenas[3..0] = mod6_min.q[3..0];
			
			tc_minutos = mod6_min.tc;
			
			%Começando a contar as horas%	
			mod24.ajuste = ajuste;
			mod24.clock_low = up & select_dig.digito[2];
			mod24.clock_high = up & select_dig.digito[3];
			mod24.enable = VCC;
			
			horas_unidades[3..0] = mod24.lsd[3..0];
			horas_dezenas[3..0] = mod24.msd[3..0];
			
			tc_horas = mod24.tc;		
		ELSE
			acorda_min_u.enable = VCC;
			acorda_min_u.clock = up & select_dig.digito[0];
			
			acorda_min_d.enable = VCC;
			acorda_min_d.clock = up & select_dig.digito[1];
			
			acorda_hora.enable = VCC;
			acorda_hora.ajuste = VCC;		
			acorda_hora.clock_low = up & select_dig.digito[2];
			acorda_hora.clock_high = up & select_dig.digito[3];
			
			min_unidades[] = acorda_min_u.q[];
			min_dezenas[] = acorda_min_d.q[];
			horas_unidades[] = acorda_hora.lsd[];
			horas_dezenas[] = acorda_hora.msd[];		
		END IF;
	ELSIF comparador THEN
		horas_unidades[3..0] = mod24.lsd[3..0];
		horas_dezenas[3..0] = mod24.msd[3..0];
		min_unidades[3..0] = mod10_min.q[3..0];
		min_dezenas[3..0] = mod6_min.q[3..0];
		sec_unidades[3..0] = mod10_seg.q[3..0];
		sec_dezenas[3..0] = mod6_seg.q[3..0];
	END IF;
		
	IF !comparador THEN	
		%Selecionando o display a ser exibido %
		chaveador.enable = VCC;
		chaveador.clock = refresh_clock.clock_saida;
		
		% Multiplexador do Display%
		
		mux.ch0[] = horas_dezenas[];
		mux.ch1[] = horas_unidades[];
		mux.ch2[] = min_dezenas[];
		mux.ch3[] = min_unidades[];
		mux.s[1..0] = chaveador.q[1..0];
		
		%Controle do Anodo %
		decoder.sel[1..0] = chaveador.q[1..0];
		
		% Decodificar BCD para 7 Segmentos%
		bcd_7Seg_dec.bcd[3..0] = mux.dout[3..0];
		bcd_7Seg_dec.lt = VCC;
		bcd_7Seg_dec.bi = VCC;
		bcd_7Seg_dec.rbi = VCC;
		
		%Saídas%
		Seg7Output[0] = bcd_7Seg_dec.a;
		Seg7Output[1] = bcd_7Seg_dec.b;
		Seg7Output[2] = bcd_7Seg_dec.c;
		Seg7Output[3] = bcd_7Seg_dec.d;
		Seg7Output[4] = bcd_7Seg_dec.e;
		Seg7Output[5] = bcd_7Seg_dec.f;
		Seg7Output[6] = bcd_7Seg_dec.g;
		
		AnodeOutput[0] = !decoder.saida[0] & (cont_clock.clock_saida & select_dig.digito[0]);
		AnodeOutput[1] = !decoder.saida[1] & (cont_clock.clock_saida & select_dig.digito[1]);
		AnodeOutput[2] = !decoder.saida[2] & (cont_clock.clock_saida & select_dig.digito[2]);
		AnodeOutput[3] = !decoder.saida[3] & (cont_clock.clock_saida & select_dig.digito[3]);
	ELSE				
		%Selecionando o display a ser exibido %
		chaveador.enable = VCC;
		chaveador.clock = refresh_clock.clock_saida;
		
		% Multiplexador do Display%
		
		mux.ch0[] = horas_dezenas[];
		mux.ch1[] = horas_unidades[];
		mux.ch2[] = min_dezenas[];
		mux.ch3[] = min_unidades[];
		mux.s[1..0] = chaveador.q[1..0];
		
		%Controle do Anodo %
		decoder.sel[1..0] = chaveador.q[1..0];
		
		% Decodificar BCD para 7 Segmentos%
		bcd_7Seg_dec.bcd[3..0] = mux.dout[3..0];
		bcd_7Seg_dec.lt = VCC;
		bcd_7Seg_dec.bi = VCC;
		bcd_7Seg_dec.rbi = VCC;
		
		%Saídas%
		Seg7Output[0] = bcd_7Seg_dec.a;
		Seg7Output[1] = bcd_7Seg_dec.b;
		Seg7Output[2] = bcd_7Seg_dec.c;
		Seg7Output[3] = bcd_7Seg_dec.d;
		Seg7Output[4] = bcd_7Seg_dec.e;
		Seg7Output[5] = bcd_7Seg_dec.f;
		Seg7Output[6] = bcd_7Seg_dec.g;
		
		AnodeOutput[0] = !decoder.saida[0] & cont_clock.clock_saida;
		AnodeOutput[1] = !decoder.saida[1] & cont_clock.clock_saida;
		AnodeOutput[2] = !decoder.saida[2] & cont_clock.clock_saida;
		AnodeOutput[3] = !decoder.saida[3] & cont_clock.clock_saida;
		
		%Sinal para o Buzzer%
		buzzer = buzzer_clk.clock_saida;
	END IF;
END;